<!DOCTYPE html>
<html>
<head>
    <title>üó∫Ô∏è La Geogr√°fica - Tracking Live</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body { 
            margin: 0; 
            font-family: Arial, sans-serif; 
            background: #f0f0f0;
        }
        #map { 
            height: 100vh; 
            width: 100%; 
        }
        .status-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 300px;
            border: 3px solid #28a745;
        }
        .logo {
            text-align: center;
            margin-bottom: 15px;
        }
        .logo img {
            max-width: 140px;
            height: auto;
            margin-bottom: 5px;
        }
        .logo-text {
            font-size: 12px;
            color: #28a745;
            font-weight: bold;
        }
        .status-text {
            font-size: 14px;
            color: #333;
            margin: 8px 0;
        }
        .client-name {
            font-weight: bold;
            color: #28a745;
            font-size: 16px;
        }
        .rider-status {
            color: #007bff;
            font-weight: bold;
        }
        .no-data {
            text-align: center;
            color: #666;
            font-style: italic;
        }
        .eta {
            background: #28a745;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
        }
        .webhook-info {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
            font-size: 11px;
            color: #1976d2;
        }
        .connection-status {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            margin: 10px 0;
            text-align: center;
        }
        .connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="status-panel" id="statusPanel">
        <div class="logo">
            <img src="assets/logo-geografica.png" alt="La Geogr√°fica" />
            <div class="logo-text">Live Tracking</div>
        </div>
        
        <div id="connectionStatus" class="connection-status disconnected">
            üî¥ Conectando...
        </div>
        
        <div id="clientInfo" class="no-data">
            Esperando pedidos...
        </div>
        
        <div class="webhook-info">
            üì° <strong>API Endpoint:</strong><br>
            <span id="webhookUrl">POST: /api/tracking</span><br>
            <small>n8n debe enviar POST con JSON en body</small>
        </div>
    </div>

    <script>
        // üó∫Ô∏è MAPA limpio centrado en CABA
        const map = L.map('map').setView([-34.6037, -58.3816], 12);
        
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: 'üõµ La Geogr√°fica - Tracking Live',
            maxZoom: 19
        }).addTo(map);

        // üéØ VARIABLES GLOBALES
        let currentRoute = null;
        let currentMarkers = [];
        let riderMarker = null;
        let animationInterval = null;
        let autoCleanTimer = null;
        let pollInterval = null;

        // üßπ LIMPIAR MAPA
        function clearMap() {
            if (currentRoute) map.removeLayer(currentRoute);
            currentMarkers.forEach(marker => map.removeLayer(marker));
            if (riderMarker) map.removeLayer(riderMarker);
            if (animationInterval) clearInterval(animationInterval);
            
            currentRoute = null;
            currentMarkers = [];
            riderMarker = null;
            
            document.getElementById('clientInfo').innerHTML = '<div class="no-data">Esperando pedidos...</div>';
        }

        // üîß DEDUPLICAR COORDENADAS (mismo que tu Python)
        function dedupeCoords(coords) {
            const seen = new Set();
            const output = [];
            for (const coord of coords) {
                const key = `${coord[0]},${coord[1]}`;
                if (!seen.has(key)) {
                    output.push(coord);
                    seen.add(key);
                }
            }
            return output;
        }

        // üìè HAVERSINE DISTANCE (mismo que tu Python)
        function haversineKm(lat1, lon1, lat2, lon2) {
            const R = 6371.0088;
            const dlat = (lat2 - lat1) * Math.PI / 180;
            const dlon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dlat/2) * Math.sin(dlat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dlon/2) * Math.sin(dlon/2);
            return 2 * R * Math.asin(Math.sqrt(a));
        }

        // üß≠ NEAREST NEIGHBOR PATH (exactamente como tu Python)
        function nearestNeighborPath(latlonPoints, startIdx = 0) {
            const n = latlonPoints.length;
            if (n <= 1) return latlonPoints;
            
            const unvisited = new Set(Array.from({length: n}, (_, i) => i));
            const order = [startIdx];
            unvisited.delete(startIdx);
            
            while (unvisited.size > 0) {
                const last = order[order.length - 1];
                let nextIdx = -1;
                let minDist = Infinity;
                
                for (const j of unvisited) {
                    const dist = haversineKm(
                        latlonPoints[last][0], latlonPoints[last][1],
                        latlonPoints[j][0], latlonPoints[j][1]
                    );
                    if (dist < minDist) {
                        minDist = dist;
                        nextIdx = j;
                    }
                }
                
                order.push(nextIdx);
                unvisited.delete(nextIdx);
            }
            
            return order.map(i => latlonPoints[i]);
        }

        // üó∫Ô∏è MOSTRAR TRACKING
        function showTracking(data) {
            clearMap();
            
            const trackingData = Array.isArray(data) ? data[0] : data;
            const ruta = trackingData.ruta_calculada?.ruta;
            const cliente = trackingData.ruta_calculada?.cliente;
            const tienda = trackingData.ruta_calculada?.tienda;
            const rider = trackingData.rider;
            
            if (!ruta || !cliente || !tienda) {
                console.error('Datos incompletos:', trackingData);
                return;
            }

            // üìç PROCESAR COORDENADAS CON NEAREST NEIGHBOR
            let coords = ruta.coordenadas_array || [];
            
            // Convertir a [lat, lon] (de [lon, lat])
            coords = coords.map(c => [c[1], c[0]]);
            
            // Deduplicar
            coords = dedupeCoords(coords);
            
            // Aplicar nearest neighbor para ordenar correctamente
            coords = nearestNeighborPath(coords, 0);
            
            console.log(`üó∫Ô∏è Procesadas ${coords.length} coordenadas con Nearest Neighbor`);

            // üó∫Ô∏è RUTA (VERDE como La Geogr√°fica)
            currentRoute = L.polyline(coords, {
                color: '#28a745',
                weight: 6,
                opacity: 0.9
            }).addTo(map);

            // üè™ TIENDA (punto inicio)
            const tiendaMarker = L.marker([tienda.lat, tienda.lon], {
                icon: L.icon({
                    iconUrl: 'data:image/svg+xml;base64,' + btoa(`
                        <svg width="35" height="35" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="17.5" cy="17.5" r="15" fill="#28a745" stroke="white" stroke-width="3"/>
                            <text x="17.5" y="23" text-anchor="middle" font-size="16" fill="white">üè™</text>
                        </svg>
                    `),
                    iconSize: [35, 35],
                    iconAnchor: [17.5, 17.5]
                })
            }).bindPopup(`üè™ INICIO<br><strong>${tienda.nombre}</strong><br>${tienda.direccion}`).addTo(map);

            // üë§ CLIENTE (punto final)
            const clienteMarker = L.marker([cliente.lat, cliente.lon], {
                icon: L.icon({
                    iconUrl: 'data:image/svg+xml;base64,' + btoa(`
                        <svg width="35" height="35" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="17.5" cy="17.5" r="15" fill="#dc3545" stroke="white" stroke-width="3"/>
                            <text x="17.5" y="23" text-anchor="middle" font-size="16" fill="white">üéØ</text>
                        </svg>
                    `),
                    iconSize: [35, 35],
                    iconAnchor: [17.5, 17.5]
                })
            }).bindPopup(`üéØ DESTINO<br><strong>${cliente.nombre}</strong><br>${cliente.direccion}`).addTo(map);

            // üõµ RIDER ANIMADO
            let currentStep = 0;
            riderMarker = L.marker(coords[0], {
                icon: L.icon({
                    iconUrl: 'data:image/svg+xml;base64,' + btoa(`
                        <svg width="30" height="30" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="15" cy="15" r="12" fill="#007bff" stroke="white" stroke-width="2"/>
                            <text x="15" y="20" text-anchor="middle" font-size="14" fill="white">üõµ</text>
                        </svg>
                    `),
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                })
            }).bindPopup(`üõµ ${rider?.nombre || 'Rider'} en ruta`).addTo(map);

            currentMarkers = [tiendaMarker, clienteMarker];

            // üé¨ ANIMACI√ìN RIDER siguiendo la ruta ordenada
            animationInterval = setInterval(() => {
                currentStep = (currentStep + 1) % coords.length;
                riderMarker.setLatLng(coords[currentStep]);
                
                // Actualizar popup con progreso
                const progress = Math.round((currentStep / coords.length) * 100);
                riderMarker.setPopupContent(`üõµ ${rider?.nombre || 'Rider'} - ${progress}% completado`);
            }, 1500);

            // üì± ACTUALIZAR PANEL
            const eta = trackingData.eta_minutos || Math.round(ruta.tiempo_calculado_minutos);
            document.getElementById('clientInfo').innerHTML = `
                <div class="client-name">¬°Hola ${cliente.nombre}!</div>
                <div class="status-text">üìç Pedido recibido</div>
                <div class="status-text">‚úÖ Pedido preparado</div>
                <div class="status-text">üõµ Rider en camino</div>
                <div class="rider-status">${rider?.nombre || 'Carlos'} est√° siguiendo la ruta</div>
                <div class="eta">‚è±Ô∏è Llegada estimada: ${eta} minutos</div>
                <div class="status-text" style="font-size: 11px; color: #666; margin-top: 10px;">
                    Ruta optimizada con ${coords.length} puntos
                </div>
            `;

            // üéØ ZOOM autom√°tico para mostrar toda la ruta
            const group = L.featureGroup([tiendaMarker, clienteMarker, currentRoute]);
            map.fitBounds(group.getBounds().pad(0.1));

            // ‚è∞ AUTO-LIMPIAR despu√©s de 10 minutos
            if (autoCleanTimer) clearTimeout(autoCleanTimer);
            autoCleanTimer = setTimeout(() => {
                clearMap();
                map.setView([-34.6037, -58.3816], 12);
            }, 10 * 60 * 1000);
        }

        // üì° POLLING PARA OBTENER DATOS
        async function pollTrackingData() {
            try {
                const response = await fetch('/api/tracking');
                const result = await response.json();
                
                if (result.success && result.data) {
                    console.log('üì° Data encontrada:', result.data);
                    showTracking(result.data);
                    updateConnectionStatus(true);
                } else {
                    updateConnectionStatus(true);
                }
            } catch (error) {
                console.error('Error polling data:', error);
                updateConnectionStatus(false);
            }
        }

        // üîó ACTUALIZAR STATUS DE CONEXI√ìN
        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connectionStatus');
            if (connected) {
                statusElement.className = 'connection-status connected';
                statusElement.textContent = 'üü¢ Conectado - Escuchando n8n';
            } else {
                statusElement.className = 'connection-status disconnected';
                statusElement.textContent = 'üî¥ Error de conexi√≥n';
            }
        }

        // üöÄ INICIALIZAR
        function init() {
            console.log('üó∫Ô∏è La Geogr√°fica Live Tracking iniciado');
            
            // Mostrar URL del webhook
            const webhookUrl = `${window.location.origin}/api/tracking`;
            document.getElementById('webhookUrl').innerHTML = `
                <code>${webhookUrl}</code><br>
                <small>Configurar en n8n como POST request</small>
            `;
            
            // Iniciar polling cada 3 segundos
            pollInterval = setInterval(pollTrackingData, 3000);
            
            // Primera verificaci√≥n inmediata
            pollTrackingData();
        }

        // üé¨ INICIAR cuando carga la p√°gina
        init();

        // üßπ LIMPIAR al cerrar
        window.addEventListener('beforeunload', () => {
            if (pollInterval) clearInterval(pollInterval);
            if (animationInterval) clearInterval(animationInterval);
            if (autoCleanTimer) clearTimeout(autoCleanTimer);
        });
    </script>
</body>
</html>