<!DOCTYPE html>
<html>
<head>
    <title>üó∫Ô∏è La Geogr√°fica - Tracking Live</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body { 
            margin: 0; 
            font-family: Arial, sans-serif; 
            background: #f0f0f0;
        }
        #map { 
            height: 100vh; 
            width: 100%; 
        }
        .leaflet-control-zoom {
            display: none !important;
        }
        .status-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 300px;
            border: 3px solid #28a745;
        }
        .logo {
            text-align: center;
            margin-bottom: 15px;
        }
        .logo img {
            max-width: 140px;
            height: auto;
            margin-bottom: 5px;
        }
        .logo-text {
            font-size: 12px;
            color: #28a745;
            font-weight: bold;
        }
        .status-text {
            font-size: 14px;
            color: #333;
            margin: 8px 0;
        }
        .client-name {
            font-weight: bold;
            color: #28a745;
            font-size: 16px;
        }
        .rider-status {
            color: #007bff;
            font-weight: bold;
        }
        .no-data {
            text-align: center;
            color: #666;
            font-style: italic;
        }
        .eta {
            background: #28a745;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
        }
        .webhook-info {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
            font-size: 11px;
            color: #1976d2;
        }
        .connection-status {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            margin: 10px 0;
            text-align: center;
        }
        .connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="status-panel" id="statusPanel">
        <div class="logo">
            <img src="assets/logo-geografica.png" alt="La Geogr√°fica" />
            <div class="logo-text">Live Tracking</div>
        </div>
        
        <div id="connectionStatus" class="connection-status disconnected">
            üî¥ Conectando...
        </div>
        
        <div id="clientInfo" class="no-data">
            Esperando pedidos...
        </div>
    </div>

    <script>
        // üó∫Ô∏è MAPA limpio centrado en CABA (SIN ZOOM CONTROLS)
        const map = L.map('map', {
            zoomControl: false,
            scrollWheelZoom: true,
            doubleClickZoom: true,
            touchZoom: true
        }).setView([-34.6037, -58.3816], 12);
        
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            attribution: 'üõµ La Geogr√°fica - Tracking Live',
            maxZoom: 19
        }).addTo(map);

        // üéØ VARIABLES GLOBALES
        let currentRoute = null;
        let currentMarkers = [];
        let riderMarker = null;
        let animationInterval = null;
        let autoCleanTimer = null;
        let pollInterval = null;

        // üßπ LIMPIAR MAPA
        function clearMap() {
            if (currentRoute) map.removeLayer(currentRoute);
            currentMarkers.forEach(marker => map.removeLayer(marker));
            if (riderMarker) map.removeLayer(riderMarker);
            if (animationInterval) clearInterval(animationInterval);
            
            currentRoute = null;
            currentMarkers = [];
            riderMarker = null;
            
            document.getElementById('clientInfo').innerHTML = '<div class="no-data">Esperando pedidos...</div>';
        }

        // üîß DEDUPLICAR COORDENADAS (mismo que tu Python)
        function dedupeCoords(coords) {
            const seen = new Set();
            const output = [];
            for (const coord of coords) {
                const key = `${coord[0]},${coord[1]}`;
                if (!seen.has(key)) {
                    output.push(coord);
                    seen.add(key);
                }
            }
            return output;
        }

        // üìè HAVERSINE DISTANCE (mismo que tu Python)
        function haversineKm(lat1, lon1, lat2, lon2) {
            const R = 6371.0088;
            const dlat = (lat2 - lat1) * Math.PI / 180;
            const dlon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dlat/2) * Math.sin(dlat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dlon/2) * Math.sin(dlon/2);
            return 2 * R * Math.asin(Math.sqrt(a));
        }

        // üß≠ NEAREST NEIGHBOR PATH (exactamente como tu Python)
        function nearestNeighborPath(latlonPoints, startIdx = 0) {
            const n = latlonPoints.length;
            if (n <= 1) return latlonPoints;
            
            const unvisited = new Set(Array.from({length: n}, (_, i) => i));
            const order = [startIdx];
            unvisited.delete(startIdx);
            
            while (unvisited.size > 0) {
                const last = order[order.length - 1];
                let nextIdx = -1;
                let minDist = Infinity;
                
                for (const j of unvisited) {
                    const dist = haversineKm(
                        latlonPoints[last][0], latlonPoints[last][1],
                        latlonPoints[j][0], latlonPoints[j][1]
                    );
                    if (dist < minDist) {
                        minDist = dist;
                        nextIdx = j;
                    }
                }
                
                order.push(nextIdx);
                unvisited.delete(nextIdx);
            }
            
            return order.map(i => latlonPoints[i]);
        }

        // üó∫Ô∏è MOSTRAR TRACKING
        function showTracking(data) {
            clearMap();
            
            const trackingData = Array.isArray(data) ? data[0] : data;
            const ruta = trackingData.ruta_calculada?.ruta;
            const cliente = trackingData.ruta_calculada?.cliente;
            const tienda = trackingData.ruta_calculada?.tienda;
            const rider = trackingData.rider;
            
            if (!ruta || !cliente || !tienda) {
                console.error('Datos incompletos:', trackingData);
                return;
            }

            // üìç PROCESAR COORDENADAS CON NEAREST NEIGHBOR
            let coords = ruta.coordenadas_array || [];
            
            // Convertir a [lat, lon] (de [lon, lat])
            coords = coords.map(c => [c[1], c[0]]);
            
            // Deduplicar
            coords = dedupeCoords(coords);
            
            // Aplicar nearest neighbor para ordenar correctamente
            coords = nearestNeighborPath(coords, 0);
            
            console.log(`üó∫Ô∏è Procesadas ${coords.length} coordenadas con Nearest Neighbor`);

            // üó∫Ô∏è RUTA (VERDE como La Geogr√°fica)
            currentRoute = L.polyline(coords, {
                color: '#28a745',
                weight: 6,
                opacity: 0.9
            }).addTo(map);

            // üè™ TIENDA (ICONO GRANDE DE LOCAL)
            const tiendaMarker = L.marker([tienda.lat, tienda.lon], {
                icon: L.icon({
                    iconUrl: 'data:image/svg+xml;base64,' + btoa(`
                        <svg width="50" height="50" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="25" cy="25" r="22" fill="#28a745" stroke="white" stroke-width="4"/>
                            <g transform="translate(25,25)">
                                <path d="M-12,-8 L12,-8 L10,0 L8,8 L-8,8 L-10,0 Z" fill="white"/>
                                <rect x="-10" y="-2" width="20" height="3" fill="#28a745"/>
                                <rect x="-8" y="2" width="16" height="4" fill="white"/>
                                <circle cx="0" cy="-6" r="2" fill="white"/>
                            </g>
                        </svg>
                    `),
                    iconSize: [50, 50],
                    iconAnchor: [25, 25]
                })
            }).bindPopup(`
                <div style="text-align: center; font-weight: bold; color: #28a745;">
                    üè™ TIENDA<br>
                    <strong>${tienda.nombre}</strong><br>
                    <small>${tienda.direccion}</small>
                </div>
            `).addTo(map);

            // üè† CLIENTE (ICONO GRANDE DE CASA)
            const clienteMarker = L.marker([cliente.lat, cliente.lon], {
                icon: L.icon({
                    iconUrl: 'data:image/svg+xml;base64,' + btoa(`
                        <svg width="50" height="50" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="25" cy="25" r="22" fill="#dc3545" stroke="white" stroke-width="4"/>
                            <g transform="translate(25,25)">
                                <path d="M-10,2 L0,-8 L10,2 L10,10 L-10,10 Z" fill="white"/>
                                <rect x="-8" y="0" width="16" height="10" fill="white"/>
                                <rect x="-6" y="2" width="5" height="6" fill="#dc3545"/>
                                <rect x="1" y="4" width="3" height="4" fill="#dc3545"/>
                                <circle cx="2.5" cy="5.5" r="0.5" fill="white"/>
                                <path d="M-10,2 L0,-8 L10,2" stroke="#dc3545" stroke-width="2" fill="none"/>
                            </g>
                        </svg>
                    `),
                    iconSize: [50, 50],
                    iconAnchor: [25, 25]
                })
            }).bindPopup(`
                <div style="text-align: center; font-weight: bold; color: #dc3545;">
                    üè† DESTINO<br>
                    <strong>${cliente.nombre}</strong><br>
                    <small>${cliente.direccion}</small>
                </div>
            `).addTo(map);

            // üõµ RIDER ANIMADO (M√ÅS PEQUE√ëO)
            let currentStep = 0;
            riderMarker = L.marker(coords[0], {
                icon: L.icon({
                    iconUrl: 'data:image/svg+xml;base64,' + btoa(`
                        <svg width="35" height="35" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="17.5" cy="17.5" r="15" fill="#007bff" stroke="white" stroke-width="3"/>
                            <g transform="translate(17.5,17.5)">
                                <circle cx="-3" cy="-2" r="6" fill="white"/>
                                <circle cx="5" cy="-2" r="6" fill="white"/>
                                <rect x="-8" y="-5" width="16" height="6" rx="3" fill="white"/>
                                <circle cx="-3" cy="-2" r="3" fill="#007bff"/>
                                <circle cx="5" cy="-2" r="3" fill="#007bff"/>
                                <rect x="-1" y="-8" width="2" height="6" fill="white"/>
                            </g>
                        </svg>
                    `),
                    iconSize: [35, 35],
                    iconAnchor: [17.5, 17.5]
                })
            }).bindPopup(`üõµ ${rider?.nombre || 'Rider'} en ruta`).addTo(map);

            currentMarkers = [tiendaMarker, clienteMarker];

            // üé¨ ANIMACI√ìN RIDER siguiendo la ruta ordenada
            let animationStartTime = Date.now();
            animationInterval = setInterval(() => {
                const elapsed = (Date.now() - animationStartTime) / 1000; // segundos transcurridos
                
                if (elapsed < 10) {
                    // Primeros 10 segundos: quedarse en la tienda
                    riderMarker.setLatLng(coords[0]);
                    const riderNombre = rider?.nombre || 'Carlos';
                    riderMarker.setPopupContent(`üõµ ${riderNombre} - Preparando pedido...`);
                } else {
                    // Despu√©s de 10 seg: empezar a moverse por la ruta
                    const routeElapsed = elapsed - 10; // tiempo desde que empez√≥ a moverse
                    const totalRouteTime = 120; // 2 minutos para completar ruta
                    const routeProgress = Math.min(routeElapsed / totalRouteTime, 1);
                    
                    const targetIndex = Math.floor(routeProgress * (coords.length - 1));
                    
                    if (targetIndex < coords.length) {
                        riderMarker.setLatLng(coords[targetIndex]);
                        
                        const progress = Math.round(routeProgress * 100);
                        const riderNombre = rider?.nombre || 'Carlos';
                        
                        if (progress >= 100) {
                            riderMarker.setPopupContent(`üõµ ${riderNombre} - ¬°Lleg√≥!`);
                        } else {
                            riderMarker.setPopupContent(`üõµ ${riderNombre} - ${progress}% del recorrido`);
                        }
                    }
                }
            }, 500); // Cada medio segundo para m√°s suavidad

            // üì± ACTUALIZAR PANEL CON ESTADOS DIN√ÅMICOS
            const eta = trackingData.eta_minutos || Math.round(ruta.tiempo_calculado_minutos);
            const riderNombre = rider?.nombre || 'Carlos';
            
            // Estados que cambian con el tiempo
            let statusStartTime = Date.now();
            
            function updateStatus() {
                const elapsed = (Date.now() - statusStartTime) / 1000;
                let currentStatus = '';
                
                if (elapsed < 10) {
                    currentStatus = `
                        <div class="status-text">üìç Recibimos tu pedido</div>
                        <div class="status-text">üîÑ Estamos preparando tu pedido</div>
                        <div class="status-text" style="color: #007bff;">‚è≥ ${riderNombre} lleg√≥ al local</div>
                    `;
                } else {
                    currentStatus = `
                        <div class="status-text">‚úÖ Pedido preparado</div>
                        <div class="status-text">‚úÖ ${riderNombre} recogi√≥ el pedido</div>
                        <div class="rider-status">üõµ ${riderNombre} est√° yendo a tu domicilio</div>
                    `;
                }
                
                document.getElementById('clientInfo').innerHTML = `
                    <div class="client-name">¬°Hola ${cliente.nombre}!</div>
                    ${currentStatus}
                    <div class="eta">‚è±Ô∏è Llegada estimada: ${eta} minutos</div>
                    <div class="status-text" style="font-size: 11px; color: #666; margin-top: 10px;">
                        Ruta optimizada ‚Ä¢ ${coords.length} puntos de seguimiento
                    </div>
                `;
            }
            
            // Actualizar status inicial
            updateStatus();
            
            // Actualizar status cada 5 segundos
            const statusUpdateInterval = setInterval(updateStatus, 5000);
            
            // Limpiar interval cuando se limpia el mapa
            if (autoCleanTimer) clearTimeout(autoCleanTimer);
            autoCleanTimer = setTimeout(() => {
                clearInterval(statusUpdateInterval);
                clearMap();
                map.setView([-34.6037, -58.3816], 12);
            }, 10 * 60 * 1000);

            // üéØ ZOOM autom√°tico para mostrar toda la ruta
            const group = L.featureGroup([tiendaMarker, clienteMarker, currentRoute]);
            map.fitBounds(group.getBounds().pad(0.1));

            // ‚è∞ AUTO-LIMPIAR despu√©s de 10 minutos
            if (autoCleanTimer) clearTimeout(autoCleanTimer);
            autoCleanTimer = setTimeout(() => {
                clearMap();
                map.setView([-34.6037, -58.3816], 12);
            }, 10 * 60 * 1000);
        }

        // üì° POLLING PARA OBTENER DATOS
        async function pollTrackingData() {
            try {
                const response = await fetch('/api/tracking');
                const result = await response.json();
                
                if (result.success && result.data) {
                    console.log('üì° Data encontrada:', result.data);
                    showTracking(result.data);
                    updateConnectionStatus(true);
                } else {
                    updateConnectionStatus(true);
                }
            } catch (error) {
                console.error('Error polling data:', error);
                updateConnectionStatus(false);
            }
        }

        // üîó ACTUALIZAR STATUS DE CONEXI√ìN
        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connectionStatus');
            if (connected) {
                statusElement.className = 'connection-status connected';
                statusElement.textContent = 'üü¢ Conectado - Escuchando n8n';
            } else {
                statusElement.className = 'connection-status disconnected';
                statusElement.textContent = 'üî¥ Error de conexi√≥n';
            }
        }

        // üöÄ INICIALIZAR
        function init() {
            console.log('üó∫Ô∏è La Geogr√°fica Live Tracking iniciado');
            
            // Iniciar polling cada 3 segundos
            pollInterval = setInterval(pollTrackingData, 3000);
            
            // Primera verificaci√≥n inmediata
            pollTrackingData();
        }

        // üé¨ INICIAR cuando carga la p√°gina
        init();

        // üßπ LIMPIAR al cerrar
        window.addEventListener('beforeunload', () => {
            if (pollInterval) clearInterval(pollInterval);
            if (animationInterval) clearInterval(animationInterval);
            if (autoCleanTimer) clearTimeout(autoCleanTimer);
        });
    </script>
</body>
</html>